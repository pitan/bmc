package ipmi

import (
	"bytes"
	"testing"

	"github.com/google/go-cmp/cmp"
	"github.com/google/gopacket"
	"github.com/google/gopacket/layers"
)

var RAKPMessage1Data = []struct {
	wire  []byte
	layer *RAKPMessage1
}{
	{
		[]byte{
			0x22,
			0x00, 0x00,
			0x00, 0x04, 0x03, 0x02, 0x01,
			0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
			0x02,
			0x00, 0x00,
			0x00},
		// empty username, role-based lookup
		&RAKPMessage1{
			BaseLayer: layers.BaseLayer{
				Contents: []byte{
					0x22, 0x00, 0x00, 0x00, 0x04, 0x03, 0x02, 0x01, 0x00,
					0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,
					0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x02, 0x00, 0x00,
					0x00},
			},
			Tag:                    0x22,
			ManagedSystemSessionID: 0x1020304,
			RemoteConsoleRandom: [16]byte{
				0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
				0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f},
			PrivilegeLevelLookup: true,
			MaxPrivilegeLevel:    PrivilegeLevelUser,
		},
	},
	{
		[]byte{
			0x01,
			0x00, 0x00,
			0x00, 0x01, 0x02, 0x03, 0x04,
			0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
			0x14,
			0x00, 0x00,
			0x06,
			'g', 'e', 'o', 'r', 'g', 'e'},
		// non-empty username, username only lookup
		&RAKPMessage1{
			BaseLayer: layers.BaseLayer{
				Contents: []byte{
					0x01, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x00,
					0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,
					0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x14, 0x00, 0x00,
					0x06, 'g', 'e', 'o', 'r', 'g', 'e'},
			},
			Tag:                    0x1,
			ManagedSystemSessionID: 0x4030201,
			RemoteConsoleRandom: [16]byte{
				0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
				0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f},
			PrivilegeLevelLookup: false,
			MaxPrivilegeLevel:    PrivilegeLevelAdministrator,
			Username:             "george",
		},
	},
	{
		[]byte{
			0xff,
			0x00, 0x00,
			0x00, 0x03, 0x02, 0x04, 0x01,
			0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
			0x03,
			0x00, 0x00,
			0x06,
			'g', 'e', 'o', 'r', 'g', 'e'},
		// non-empty username, role-based lookup
		&RAKPMessage1{
			BaseLayer: layers.BaseLayer{
				Contents: []byte{
					0xff, 0x00, 0x00, 0x00, 0x03, 0x02, 0x04, 0x01, 0x00,
					0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,
					0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x03, 0x00, 0x00,
					0x06, 'g', 'e', 'o', 'r', 'g', 'e'},
			},
			Tag:                    0xff,
			ManagedSystemSessionID: 0x1040203,
			RemoteConsoleRandom: [16]byte{
				0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
				0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f},
			PrivilegeLevelLookup: true,
			MaxPrivilegeLevel:    PrivilegeLevelOperator,
			Username:             "george",
		},
	},
}

func TestRAKPMessage1DecodeFromBytes(t *testing.T) {
	layer := &RAKPMessage1{}
	for _, test := range RAKPMessage1Data {
		err := layer.DecodeFromBytes(test.wire, gopacket.NilDecodeFeedback)
		switch {
		case err == nil && test.layer == nil:
			t.Errorf("decode %v succeeded with %v, wanted error", test.wire,
				layer)
		case err != nil && test.layer != nil:
			t.Errorf("decode %v failed with %v, wanted %v", test.wire, err,
				test.layer)
		case err == nil && test.layer != nil:
			if diff := cmp.Diff(test.layer, layer); diff != "" {
				t.Errorf("decode %v = %v, want %v: %v", test.wire, layer, test.layer, diff)
			}
		}
	}
}

func TestRAKPMessage1SerializeTo(t *testing.T) {
	opts := gopacket.SerializeOptions{}
	for _, test := range RAKPMessage1Data {
		sb := gopacket.NewSerializeBuffer()
		if err := test.layer.SerializeTo(sb, opts); err != nil {
			t.Errorf("serialize %v = error %v, want %v", test.layer, err,
				test.wire)
			continue
		}
		got := sb.Bytes()
		if !bytes.Equal(got, test.wire) {
			t.Errorf("serialize %v = %v, want %v", test.layer, got, test.wire)
		}
	}
}
